<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Asteroids</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #000;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      overflow: hidden;
      font-family: 'Courier New', monospace;
    }
    canvas {
      border: 1px solid #333;
      display: block;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <script>
    // ── Canvas Setup ──
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = 800;
    canvas.height = 600;

    // ── Constants ──
    const SHIP_SIZE = 15;
    const TURN_SPEED = 0.07;
    const THRUST_POWER = 0.1;
    const FRICTION = 0.99;
    const BULLET_SPEED = 7;
    const BULLET_LIFETIME = 60;
    const MAX_BULLETS = 10;
    const ASTEROID_SPEED = 1.5;
    const ASTEROID_VERTICES_MIN = 7;
    const ASTEROID_VERTICES_MAX = 12;
    const ASTEROID_JAG = 0.4;
    const INITIAL_ASTEROIDS = 5;
    const INVINCIBILITY_FRAMES = 120;
    const PARTICLE_COUNT = 15;
    const PARTICLE_LIFETIME = 30;
    const STARTING_LIVES = 3;

    // ── Score Values ──
    const SCORE_LARGE = 20;
    const SCORE_MEDIUM = 50;
    const SCORE_SMALL = 100;
    const EXTRA_LIFE_SCORE = 10000;

    // ── Game State ──
    let ship, asteroids, bullets, particles, keys;
    let score, highScore, lives, level;
    let gameOver, paused, invincibilityTimer;
    let nextExtraLife;
    let gameStarted = false;

    // Load high score from localStorage
    highScore = parseInt(localStorage.getItem('asteroids-highscore')) || 0;

    // ── Input Handling ──
    keys = {};
    document.addEventListener('keydown', (e) => {
      keys[e.code] = true;
      if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'ArrowDown') {
        e.preventDefault();
      }
      if (e.code === 'Enter' && gameOver) {
        startGame();
      }
      if (e.code === 'Enter' && !gameStarted) {
        gameStarted = true;
        startGame();
      }
      if (e.code === 'KeyP' && gameStarted && !gameOver) {
        paused = !paused;
      }
    });
    document.addEventListener('keyup', (e) => {
      keys[e.code] = false;
    });

    // ── Helper Functions ──
    function randomRange(min, max) {
      return Math.random() * (max - min) + min;
    }

    function distanceBetween(x1, y1, x2, y2) {
      return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
    }

    function wrapPosition(obj) {
      if (obj.x < -obj.radius) obj.x = canvas.width + obj.radius;
      if (obj.x > canvas.width + obj.radius) obj.x = -obj.radius;
      if (obj.y < -obj.radius) obj.y = canvas.height + obj.radius;
      if (obj.y > canvas.height + obj.radius) obj.y = -obj.radius;
    }

    // ── Entity Creation ──
    function createShip() {
      return {
        x: canvas.width / 2,
        y: canvas.height / 2,
        radius: SHIP_SIZE,
        angle: -Math.PI / 2,
        velX: 0,
        velY: 0,
        thrusting: false,
        canShoot: true
      };
    }

    function createAsteroid(x, y, size) {
      const sizeRadius = size === 'large' ? 40 : size === 'medium' ? 20 : 10;
      const angle = Math.random() * Math.PI * 2;
      const speed = ASTEROID_SPEED * (1 + level * 0.1) * (size === 'small' ? 1.5 : size === 'medium' ? 1.2 : 1);

      // Generate jagged vertices
      const vertexCount = Math.floor(randomRange(ASTEROID_VERTICES_MIN, ASTEROID_VERTICES_MAX));
      const offsets = [];
      for (let i = 0; i < vertexCount; i++) {
        offsets.push(1 + Math.random() * ASTEROID_JAG * 2 - ASTEROID_JAG);
      }

      return {
        x: x,
        y: y,
        velX: Math.cos(angle) * speed,
        velY: Math.sin(angle) * speed,
        radius: sizeRadius,
        size: size,
        vertexCount: vertexCount,
        offsets: offsets,
        rotAngle: 0,
        rotSpeed: (Math.random() - 0.5) * 0.04
      };
    }

    function spawnAsteroids(count) {
      for (let i = 0; i < count; i++) {
        let x, y;
        // Spawn away from ship
        do {
          x = Math.random() * canvas.width;
          y = Math.random() * canvas.height;
        } while (distanceBetween(x, y, ship.x, ship.y) < 150);

        asteroids.push(createAsteroid(x, y, 'large'));
      }
    }

    function createBullet() {
      return {
        x: ship.x + Math.cos(ship.angle) * SHIP_SIZE,
        y: ship.y + Math.sin(ship.angle) * SHIP_SIZE,
        velX: Math.cos(ship.angle) * BULLET_SPEED + ship.velX * 0.5,
        velY: Math.sin(ship.angle) * BULLET_SPEED + ship.velY * 0.5,
        radius: 2,
        life: BULLET_LIFETIME
      };
    }

    function createParticles(x, y, color) {
      for (let i = 0; i < PARTICLE_COUNT; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = randomRange(1, 4);
        particles.push({
          x: x,
          y: y,
          velX: Math.cos(angle) * speed,
          velY: Math.sin(angle) * speed,
          life: PARTICLE_LIFETIME + Math.random() * 15,
          maxLife: PARTICLE_LIFETIME + 15,
          color: color || '#FFA500',
          size: randomRange(1, 3)
        });
      }
    }

    // ── Game Initialization ──
    function startGame() {
      ship = createShip();
      asteroids = [];
      bullets = [];
      particles = [];
      score = 0;
      lives = STARTING_LIVES;
      level = 1;
      gameOver = false;
      paused = false;
      invincibilityTimer = INVINCIBILITY_FRAMES;
      nextExtraLife = EXTRA_LIFE_SCORE;
      spawnAsteroids(INITIAL_ASTEROIDS);
    }

    // ── Update Logic ──
    function update() {
      if (paused || gameOver || !gameStarted) return;

      // Ship rotation
      if (keys['ArrowLeft'] || keys['KeyA']) {
        ship.angle -= TURN_SPEED;
      }
      if (keys['ArrowRight'] || keys['KeyD']) {
        ship.angle += TURN_SPEED;
      }

      // Ship thrust
      ship.thrusting = keys['ArrowUp'] || keys['KeyW'];
      if (ship.thrusting) {
        ship.velX += Math.cos(ship.angle) * THRUST_POWER;
        ship.velY += Math.sin(ship.angle) * THRUST_POWER;
      }

      // Apply friction
      ship.velX *= FRICTION;
      ship.velY *= FRICTION;

      // Move ship
      ship.x += ship.velX;
      ship.y += ship.velY;
      wrapPosition(ship);

      // Shooting
      if ((keys['Space'] || keys['KeyF']) && ship.canShoot && bullets.length < MAX_BULLETS) {
        bullets.push(createBullet());
        ship.canShoot = false;
      }
      if (!keys['Space'] && !keys['KeyF']) {
        ship.canShoot = true;
      }

      // Update bullets
      for (let i = bullets.length - 1; i >= 0; i--) {
        bullets[i].x += bullets[i].velX;
        bullets[i].y += bullets[i].velY;
        bullets[i].life--;

        // Wrap bullets
        if (bullets[i].x < 0) bullets[i].x = canvas.width;
        if (bullets[i].x > canvas.width) bullets[i].x = 0;
        if (bullets[i].y < 0) bullets[i].y = canvas.height;
        if (bullets[i].y > canvas.height) bullets[i].y = 0;

        if (bullets[i].life <= 0) {
          bullets.splice(i, 1);
        }
      }

      // Update asteroids
      for (let i = 0; i < asteroids.length; i++) {
        asteroids[i].x += asteroids[i].velX;
        asteroids[i].y += asteroids[i].velY;
        asteroids[i].rotAngle += asteroids[i].rotSpeed;
        wrapPosition(asteroids[i]);
      }

      // Update particles
      for (let i = particles.length - 1; i >= 0; i--) {
        particles[i].x += particles[i].velX;
        particles[i].y += particles[i].velY;
        particles[i].velX *= 0.98;
        particles[i].velY *= 0.98;
        particles[i].life--;
        if (particles[i].life <= 0) {
          particles.splice(i, 1);
        }
      }

      // Invincibility countdown
      if (invincibilityTimer > 0) {
        invincibilityTimer--;
      }

      // Bullet-Asteroid collisions
      for (let i = asteroids.length - 1; i >= 0; i--) {
        for (let j = bullets.length - 1; j >= 0; j--) {
          if (distanceBetween(bullets[j].x, bullets[j].y, asteroids[i].x, asteroids[i].y) < asteroids[i].radius) {
            // Create explosion particles
            createParticles(asteroids[i].x, asteroids[i].y, '#FFA500');

            // Score
            if (asteroids[i].size === 'large') score += SCORE_LARGE;
            else if (asteroids[i].size === 'medium') score += SCORE_MEDIUM;
            else score += SCORE_SMALL;

            // Extra life check
            if (score >= nextExtraLife) {
              lives++;
              nextExtraLife += EXTRA_LIFE_SCORE;
            }

            // Split asteroid
            if (asteroids[i].size === 'large') {
              asteroids.push(createAsteroid(asteroids[i].x, asteroids[i].y, 'medium'));
              asteroids.push(createAsteroid(asteroids[i].x, asteroids[i].y, 'medium'));
            } else if (asteroids[i].size === 'medium') {
              asteroids.push(createAsteroid(asteroids[i].x, asteroids[i].y, 'small'));
              asteroids.push(createAsteroid(asteroids[i].x, asteroids[i].y, 'small'));
            }

            asteroids.splice(i, 1);
            bullets.splice(j, 1);
            break;
          }
        }
      }

      // Ship-Asteroid collisions
      if (invincibilityTimer <= 0) {
        for (let i = 0; i < asteroids.length; i++) {
          if (distanceBetween(ship.x, ship.y, asteroids[i].x, asteroids[i].y) < ship.radius + asteroids[i].radius * 0.8) {
            // Ship hit!
            createParticles(ship.x, ship.y, '#FF4444');
            lives--;

            if (lives <= 0) {
              gameOver = true;
              if (score > highScore) {
                highScore = score;
                localStorage.setItem('asteroids-highscore', highScore);
              }
            } else {
              // Respawn ship
              ship.x = canvas.width / 2;
              ship.y = canvas.height / 2;
              ship.velX = 0;
              ship.velY = 0;
              ship.angle = -Math.PI / 2;
              invincibilityTimer = INVINCIBILITY_FRAMES;
            }
            break;
          }
        }
      }

      // Next level
      if (asteroids.length === 0) {
        level++;
        invincibilityTimer = INVINCIBILITY_FRAMES;
        spawnAsteroids(INITIAL_ASTEROIDS + level);
      }
    }

    // ── Drawing ──
    function drawShip() {
      // Blink during invincibility
      if (invincibilityTimer > 0 && Math.floor(invincibilityTimer / 6) % 2 === 0) return;

      ctx.save();
      ctx.translate(ship.x, ship.y);
      ctx.rotate(ship.angle);

      // Ship body
      ctx.strokeStyle = '#FFF';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(SHIP_SIZE, 0);
      ctx.lineTo(-SHIP_SIZE * 0.8, -SHIP_SIZE * 0.6);
      ctx.lineTo(-SHIP_SIZE * 0.4, 0);
      ctx.lineTo(-SHIP_SIZE * 0.8, SHIP_SIZE * 0.6);
      ctx.closePath();
      ctx.stroke();

      // Thrust flame
      if (ship.thrusting) {
        ctx.strokeStyle = '#F80';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(-SHIP_SIZE * 0.4, -SHIP_SIZE * 0.3);
        ctx.lineTo(-SHIP_SIZE * (0.8 + Math.random() * 0.6), 0);
        ctx.lineTo(-SHIP_SIZE * 0.4, SHIP_SIZE * 0.3);
        ctx.stroke();
      }

      ctx.restore();
    }

    function drawAsteroid(a) {
      ctx.save();
      ctx.translate(a.x, a.y);
      ctx.rotate(a.rotAngle);
      ctx.strokeStyle = '#AAA';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      for (let i = 0; i < a.vertexCount; i++) {
        const angle = (i / a.vertexCount) * Math.PI * 2;
        const r = a.radius * a.offsets[i];
        if (i === 0) {
          ctx.moveTo(Math.cos(angle) * r, Math.sin(angle) * r);
        } else {
          ctx.lineTo(Math.cos(angle) * r, Math.sin(angle) * r);
        }
      }
      ctx.closePath();
      ctx.stroke();
      ctx.restore();
    }

    function drawBullet(b) {
      ctx.fillStyle = '#FFF';
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
      ctx.fill();
    }

    function drawParticle(p) {
      const alpha = p.life / p.maxLife;
      ctx.fillStyle = p.color;
      ctx.globalAlpha = alpha;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size * alpha, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }

    function drawHUD() {
      // Score
      ctx.fillStyle = '#FFF';
      ctx.font = '24px "Courier New", monospace';
      ctx.textAlign = 'left';
      ctx.fillText(score.toString().padStart(6, '0'), 20, 35);

      // High score
      ctx.font = '14px "Courier New", monospace';
      ctx.textAlign = 'center';
      ctx.fillStyle = '#888';
      ctx.fillText('HI ' + highScore.toString().padStart(6, '0'), canvas.width / 2, 25);

      // Level
      ctx.fillStyle = '#888';
      ctx.font = '14px "Courier New", monospace';
      ctx.textAlign = 'right';
      ctx.fillText('LEVEL ' + level, canvas.width - 20, 25);

      // Lives (draw small ships)
      for (let i = 0; i < lives; i++) {
        const lx = 30 + i * 25;
        const ly = 55;
        ctx.save();
        ctx.translate(lx, ly);
        ctx.rotate(-Math.PI / 2);
        ctx.strokeStyle = '#FFF';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(8, 0);
        ctx.lineTo(-6, -5);
        ctx.lineTo(-3, 0);
        ctx.lineTo(-6, 5);
        ctx.closePath();
        ctx.stroke();
        ctx.restore();
      }
    }

    function drawTitleScreen() {
      ctx.fillStyle = '#FFF';
      ctx.font = '48px "Courier New", monospace';
      ctx.textAlign = 'center';
      ctx.fillText('ASTEROIDS', canvas.width / 2, canvas.height / 2 - 60);

      ctx.font = '18px "Courier New", monospace';
      ctx.fillStyle = '#AAA';
      ctx.fillText('PRESS ENTER TO START', canvas.width / 2, canvas.height / 2 + 10);

      ctx.font = '14px "Courier New", monospace';
      ctx.fillStyle = '#666';
      ctx.fillText('ARROW KEYS or WASD to move', canvas.width / 2, canvas.height / 2 + 60);
      ctx.fillText('SPACE or F to shoot', canvas.width / 2, canvas.height / 2 + 82);
      ctx.fillText('P to pause', canvas.width / 2, canvas.height / 2 + 104);

      if (highScore > 0) {
        ctx.fillStyle = '#888';
        ctx.font = '16px "Courier New", monospace';
        ctx.fillText('HIGH SCORE: ' + highScore.toString().padStart(6, '0'), canvas.width / 2, canvas.height / 2 + 150);
      }
    }

    function drawGameOver() {
      // Dim overlay
      ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.fillStyle = '#FF4444';
      ctx.font = '48px "Courier New", monospace';
      ctx.textAlign = 'center';
      ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 50);

      ctx.fillStyle = '#FFF';
      ctx.font = '24px "Courier New", monospace';
      ctx.fillText('SCORE: ' + score.toString().padStart(6, '0'), canvas.width / 2, canvas.height / 2 + 10);

      if (score >= highScore && score > 0) {
        ctx.fillStyle = '#FFD700';
        ctx.font = '18px "Courier New", monospace';
        ctx.fillText('NEW HIGH SCORE!', canvas.width / 2, canvas.height / 2 + 45);
      }

      ctx.fillStyle = '#AAA';
      ctx.font = '18px "Courier New", monospace';
      ctx.fillText('PRESS ENTER TO PLAY AGAIN', canvas.width / 2, canvas.height / 2 + 90);
    }

    function drawPaused() {
      ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.fillStyle = '#FFF';
      ctx.font = '36px "Courier New", monospace';
      ctx.textAlign = 'center';
      ctx.fillText('PAUSED', canvas.width / 2, canvas.height / 2);

      ctx.font = '16px "Courier New", monospace';
      ctx.fillStyle = '#AAA';
      ctx.fillText('Press P to resume', canvas.width / 2, canvas.height / 2 + 35);
    }

    // ── Starfield Background ──
    const stars = [];
    for (let i = 0; i < 100; i++) {
      stars.push({
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        size: Math.random() * 1.5,
        brightness: Math.random() * 0.5 + 0.2
      });
    }

    function drawStars() {
      for (const star of stars) {
        ctx.fillStyle = `rgba(255, 255, 255, ${star.brightness})`;
        ctx.beginPath();
        ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // ── Main Game Loop ──
    function gameLoop() {
      // Clear
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Starfield
      drawStars();

      if (!gameStarted) {
        drawTitleScreen();
        requestAnimationFrame(gameLoop);
        return;
      }

      // Update
      update();

      // Draw asteroids
      for (const a of asteroids) drawAsteroid(a);

      // Draw bullets
      for (const b of bullets) drawBullet(b);

      // Draw particles
      for (const p of particles) drawParticle(p);

      // Draw ship (if alive)
      if (!gameOver) drawShip();

      // HUD
      drawHUD();

      // Overlays
      if (paused) drawPaused();
      if (gameOver) drawGameOver();

      requestAnimationFrame(gameLoop);
    }

    // Start the loop (title screen)
    gameLoop();
  </script>
</body>
</html>
